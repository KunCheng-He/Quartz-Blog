# 0-单链表的反转

> 这题思路其实很明确，为了方便操作，我们申明一个虚拟的头节点，然后通过头插法，遍历一遍就反转了；更难的是不使用头节点的方式反转

🐼 `带头节点的反转` ，很容易想到

![[Pasted image 20230901163546.png]]

❌🐼 `不带头节点的反转` ，相比之下要难一点，当面试官禁用第一个方法后，我们也要会这个方法

![[Pasted image 20230901164446.png]]

⚠️ 从上图中可以看到，主要用两个指针，`prev` 和 `cur` ，`next` 可以当成一个临时的指针变量处理即可，通过 `cur` 指针遍历一遍后，即可完成链表反转

> 🚩 以上两个版本的反转，理解了这个过程就行，代码实现在 [LCR 024. 反转链表](https://leetcode.cn/problems/UHnkqh/) 

# 1-区间反转

![[Pasted image 20230901202925.png]]

+ 🧠 思路演进 （题目：[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)）
	+ 上面我们做了两个反转，一个是带头节点的头插法，一个是不带头节点的原地反转
	+ `1>` **头插法**：找到反转的前一个位置，然后往后遍历的不断头插过来，最后再指到剩余不用反转的节点上去即可，需要特别考虑，当反转是从头的位置开始反转时，是找不到前一个位置的，如果想规避这个特别考虑，可以用一个虚拟的头节点
	+ `2>` **穿针引线法**：思想内容（把反转的部分割下来，反转完成后在缝回去），所以细节就是需要找到临界处的四个位置，同样，为了方便处理，我们可以用一个虚拟的头节点

# 2-两两交换

题目：如题，[两两交换](https://leetcode.cn/problems/swap-nodes-in-pairs/)，后面不够两两的就不换了

![[Pasted image 20230903164200.png]]

+ 🧠 思路演进：因为要返回头节点，我们使用一个虚拟的头节点后会方便很多，之后只需要理解指针的变换顺序即可

# 3-单链表加一
---
题目：给一个数，数的高位在表头，数的低位在表尾，对该数进行加一
![[Pasted image 20230903165248.png]]

---

+ 🧠 思路演进
	+ 加法计算是从低位开始，低位如果为9，则需要考虑进一位，所以问题核心在于倒序访问，所以第一个思路，用 `栈`
	+ 倒序访问的另一个思路，`链表反转`，这个参考[[02关-链表反转#0-单链表的反转 | 第0节]] 的内容，加一完成后还需要反转回来再输出

# 4-链表相加
---
题目：[力扣](https://leetcode.cn/problems/add-two-numbers-ii/) ，给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
![[Pasted image 20230903172759.png]]

---

+ 🧠 思路演进
	+ 和上一题链表加一考点差不多，主要还是反转的问题，所以还是两个思路，用 `栈` 或者 `链表反转` 都可以，如果使用链表反转，因为要反转多次，所以将该操作封装成函数进行调用是个不错的选择

# 5-K个数组反转
---
题目：[力扣](https://leetcode.cn/problems/reverse-nodes-in-k-group/) ，给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
![[Pasted image 20230903181942.png]]

---

+ 🧠 思路演进
	+ 第一步，我们知道链表中可能有多个小组需要反转，所以我想的第一步就是把反转这个操作独立出来，单独写一个方法，就用之前的无头节点的反转方法
	+ 第二步，截出需要反转的链表，送进去反转，之后注意拼接即可（Tips：送进去反转的头节点，出来之后就是末尾节点了，拼接的时候有用）
